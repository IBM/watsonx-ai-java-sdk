/*
 * Copyright 2025 IBM Corporation
 * SPDX-License-Identifier: Apache-2.0
 */
package com.ibm.watsonx.ai.chat;

import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import com.ibm.watsonx.ai.chat.model.Tool;
import com.ibm.watsonx.ai.chat.model.ToolArguments;

/**
 * A registry for managing and executing tools that implement {@link ExecutableTool}.
 * <p>
 * The {@code ToolRegistry} provides a centralized mechanism for registering tools and executing them based on tool calls generated by the model.
 * <p>
 * <b>Example usage:</b>
 *
 * <pre>{@code
 * ToolRegistry toolRegistry = ToolRegistry.builder()
 *      .tool(new GoogleSearchTool(toolService), new WebCrawlerTool(toolService))
 *      .beforeExecution((toolName, toolArgs) -> ...)
 *      .build();
 *
 * var chatService = ChatService.builder()
 *      .baseUrl(URL)
 *      .apiKey(API_KEY)
 *      .projectId(PROJECT_ID)
 *      .modelId("ibm/granite-4-h-small")
 *      .tools(toolRegistry.tools())
 *      .build();
 *
 * List<ChatMessages> messages = ...
 * var assistantMessage = chatService.chat(messages).toAssistantMessage();
 * assistantMessage.processTools(toolRegistry::execute);
 * }</pre>
 *
 * @see ExecutableTool
 * @see ToolExecutor
 */
public class ToolRegistry implements ToolExecutor {

    private final Map<String, ExecutableTool> tools;
    private final ExecutableTool.BeforeExecution beforeExecution;
    private final ExecutableTool.AfterExecution afterExecution;
    private final ExecutableTool.OnError onError;

    /**
     * Constructs a new empty {@code ToolRegistry}.
     */
    public ToolRegistry(Builder builder) {
        if (builder.executableTools.isEmpty())
            throw new IllegalArgumentException("At least one tool must be provided");
        tools = builder.executableTools.stream().collect(Collectors.toMap(ExecutableTool::name, t -> t));
        beforeExecution = builder.beforeExecution;
        afterExecution = builder.afterExecution;
        onError = builder.onError;
    }

    @Override
    public Object execute(String toolName, ToolArguments args) {
        var tool = tools.get(toolName);
        if (isNull(tool))
            throw new IllegalArgumentException("Unknown tool: " + toolName);

        if (nonNull(beforeExecution))
            beforeExecution.accept(toolName, args);

        try {

            var result = tool.execute(args);

            if (nonNull(afterExecution))
                afterExecution.accept(toolName, args, result);

            return result;

        } catch (Exception e) {

            if (nonNull(onError))
                onError.accept(toolName, args, e);

            throw e;
        }
    }

    /**
     * Returns the schemas of all registered tools.
     *
     * @return a list of tool schemas for all registered tools
     */
    public List<Tool> tools() {
        return tools(Set.of());
    }

    /**
     * Returns the schemas of tools matching the specified names.
     *
     * @param names the tool names to include
     * @return a list of tool schemas for the matching tools
     */
    public List<Tool> tools(String... names) {
        return tools(Set.of(names));
    }

    /**
     * Returns the schemas of tools matching the specified names.
     * <p>
     * If the provided set is {@code null} or empty, all registered tool schemas are returned. Unmatched names are silently ignored.
     *
     * @param names the set of tool names to include, or empty/null for all tools
     * @return a list of tool schemas for the matching tools
     */
    public List<Tool> tools(Set<String> names) {
        var stream = tools.values().stream();

        if (!names.isEmpty())
            stream = stream.filter(tool -> names.contains(tool.name()));

        return stream.map(ExecutableTool::schema).toList();
    }

    /**
     * Creates a new builder for constructing a {@link ToolRegistry}.
     *
     * @return a new builder instance
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Builder class for constructing {@link ToolRegistry} instances with configurable tools and lifecycle callbacks.
     */
    public final static class Builder {
        private List<ExecutableTool> executableTools = Collections.synchronizedList(new ArrayList<>());
        private ExecutableTool.BeforeExecution beforeExecution;
        private ExecutableTool.AfterExecution afterExecution;
        private ExecutableTool.OnError onError;

        private Builder() {}

        /**
         * Registers a callback to be invoked immediately before each tool execution.
         *
         * @param beforeExecution the callback to invoke before tool execution
         */
        public Builder beforeExecution(ExecutableTool.BeforeExecution beforeExecution) {
            this.beforeExecution = beforeExecution;
            return this;
        }

        /**
         * Registers a callback to be invoked immediately after each successful tool execution.
         *
         * @param afterExecution the callback to invoke after successful tool execution
         */
        public Builder afterExecution(ExecutableTool.AfterExecution afterExecution) {
            this.afterExecution = afterExecution;
            return this;
        }

        /**
         * Registers a callback to be invoked when a tool execution fails with an exception.
         *
         * @param onError the callback to invoke on tool execution failure
         */
        public Builder onError(ExecutableTool.OnError onError) {
            this.onError = onError;
            return this;
        }

        /**
         * Registers one or more tools with this registry.
         *
         * @param executableTools the tools to register
         */
        public Builder register(ExecutableTool... executableTools) {
            return register(List.of(executableTools));
        }

        /**
         * Registers a list of tools with this registry.
         *
         * @param executableTools the list of tools to register
         */
        public Builder register(List<ExecutableTool> executableTools) {
            this.executableTools.addAll(executableTools);
            return this;
        }

        /**
         * Builds and returns a new {@link ToolRegistry} with the configured tools and callbacks.
         *
         * @return a new {@code ToolRegistry} instance
         */
        public ToolRegistry build() {
            return new ToolRegistry(this);
        }
    }
}