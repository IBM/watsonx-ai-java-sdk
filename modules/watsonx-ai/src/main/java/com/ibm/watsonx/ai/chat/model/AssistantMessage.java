/*
 * Copyright IBM Corp. 2025 - 2025
 * SPDX-License-Identifier: Apache-2.0
 */
package com.ibm.watsonx.ai.chat.model;

import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static java.util.Objects.requireNonNull;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import com.ibm.watsonx.ai.chat.ToolExecutor;
import com.ibm.watsonx.ai.core.Json;
import com.ibm.watsonx.ai.core.spi.json.TypeToken;

/**
 * Represents a message authored by the assistant within a chat interaction.
 * <p>
 * An {@code AssistantMessage} may contain natural language text or tool calls (e.g., function calls). Either {@code content} or {@code toolCalls}
 * must be present.
 * <p>
 * Example usage:
 *
 * <pre>{@code
 * AssistantMessage.text("Sure, here's the weather forecast: ...");
 * }</pre>
 *
 * @param role the role of the message's author, always {@code assistant}
 * @param content the assistant's message content, optional if {@code toolCalls} is provided
 * @param thinking the assistant's reasoning or internal thought process, if present
 * @param name optional name to differentiate between assistant participants
 * @param refusal an optional refusal message when the assistant declines to perform a task
 * @param toolCalls optional tool calls generated by the model
 */
public record AssistantMessage(
    String role,
    String content,
    String thinking,
    String name,
    String refusal,
    List<ToolCall> toolCalls) implements ChatMessage {

    public static final String ROLE = "assistant";

    public AssistantMessage {
        role = ROLE;
        if (isNull(content) && isNull(toolCalls))
            throw new NullPointerException("Either content or toolCalls must be specified");
    }

    public AssistantMessage(String content, String thinking, String name, String refusal, List<ToolCall> toolCalls) {
        this(ROLE, content, thinking, name, refusal, toolCalls);
    }

    /**
     * Creates a new {@link AssistantMessage}.
     *
     * @param content the assistant's message content
     * @return a new {@link AssistantMessage}
     */
    public static AssistantMessage text(String content) {
        return text(content, null);
    }

    /**
     * Creates a new {@link AssistantMessage}.
     *
     * @param content the assistant's message content
     * @param name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @return a new {@link AssistantMessage}
     */
    public static AssistantMessage text(String content, String name) {
        return new AssistantMessage(content, null, name, null, null);
    }

    /**
     * Creates a new {@link AssistantMessage} from one or more {@link ToolCall} instances.
     *
     * @param toolCalls the assistant's tool calls
     * @return a new {@link AssistantMessage}
     */
    public static AssistantMessage tools(ToolCall... toolCalls) {
        return tools(Arrays.asList(toolCalls));
    }

    /**
     * Creates a new {@link AssistantMessage} containing only tool calls.
     *
     * @param toolCalls the assistant's tool calls
     * @return a new {@link AssistantMessage}
     */
    public static AssistantMessage tools(List<ToolCall> toolCalls) {
        return tools(null, toolCalls);
    }

    /**
     * Creates a new {@link AssistantMessage}.
     *
     * @param name An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @param toolCalls the assistant's tool calls
     * @return a new {@link AssistantMessage}
     */
    public static AssistantMessage tools(String name, List<ToolCall> toolCalls) {
        return new AssistantMessage(null, null, name, null, toolCalls);
    }

    /**
     * Indicates whether this assistant message contains any tool calls.
     *
     * @return {@code true} if tool calls are present, {@code false} otherwise
     */
    public boolean hasToolCalls() {
        return nonNull(toolCalls) && !toolCalls.isEmpty();
    }

    /**
     * Deserializes the textual content of the {@code AssistantMessage} into a Java object.
     * <p>
     * Note: This method assumes the content is a valid JSON string matching the structure of the given class. If the content is not valid JSON or
     * does not match the structure of {@code clazz}, a parsing exception may be thrown.
     *
     * @param <T> the type of the object to return
     * @param clazz the target class for deserialization
     * @return an instance of {@code clazz} parsed from the response content
     */
    public <T> T toObject(Class<T> clazz) {
        requireNonNull(clazz);
        return Json.fromJson(content, clazz);
    }

    /**
     * Processes all tool calls contained in the {@link AssistantMessage} using the provided {@link ToolExecutor}, and returns a list of
     * {@link ToolMessage}.
     * <p>
     * If there are no tool calls present, this method returns an empty list.
     *
     * @param executor the executor responsible for running the tool call logic
     * @return a list of {@link ToolMessage} objects generated from each tool call, or an empty list if no tool calls are present
     */
    public List<ChatMessage> processTools(ToolExecutor executor) {
        if (!hasToolCalls())
            return List.of();

        return toolCalls.stream()
            .map(toolCall -> {
                var function = toolCall.function();

                var normalizedArgs = executor.normalize(function.arguments());

                var args = new ToolArguments(
                    Json.fromJson(normalizedArgs, new TypeToken<Map<String, Object>>() {})
                );

                var result = executor.execute(function.name(), args);
                return (ChatMessage) ToolMessage.of(result, toolCall.id());

            }).toList();
    }
}